var documenterSearchIndex = {"docs":
[{"location":"#ModelingToolkitParameters-Introduction-and-Motivation","page":"Home","title":"ModelingToolkitParameters - Introduction and Motivation","text":"Currently the standard way to build parameters up in ModelingToolkit models is with the following pattern of keyword arguments with default values.  \n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing OrdinaryDiffEq\n\n@component function Motor(; name, k = 0.1, r = 0.01, l = 1e-3)\n  pars = @parameters begin\n    k = k\n    r = r\n    l = l\n  end\n  vars = @variables begin\n    v(t)\n    dphi(t) = 0\n    i(t) = 0\n    di(t)\n  end\n  eqs = Equation[\n    D(i) ~ di\n    v ~ i * r + l * di + dphi * k\n    D(dphi) ~ k * i\n    v ~ sin(t)\n  ]\n\n  return ODESystem(eqs, t, vars, pars; name)\nend\n\nThis patern heavily relies on the defaults mechanism of the model to actually set the parameters of the model.  Let say we want k, r, l to be 1, 2, 3.  One way we can do this is\n\n@mtkbuild sys = Motor(k=1, r=2, l=3)\n\nThis is simple enough, but what if we want another instance with k, r, l to be 4, 5, 6?  Should we fully rebuild the model?  Instead it's better to set parameters at the ODEProblem level...\n\n@mtkbuild sys = Motor()\nprob = ODEProblem(sys, [], (0,1))\n\nprob1 = remake(prob; p = [sys.k => 1, sys.r => 2, sys.l => 3])\nprob2 = remake(prob; p = [sys.k => 4, sys.r => 5, sys.l => 6])\n\nNote, now we are not using the keyword arguments of the model constructor.  Instead we are building the parameter map from scratch.  Therefore, the cons of the keyword model construction pattern are:\n\nmakes the model interface more complicated.  As the list of parameters grows, the keyword list becomes un-manageable\nit's essentially useless if more than one model instance is needed\nbuilding a parameter map for remake still needs to be done from scratch.  (We could get the defaults dictionary of the model, but we still need to index into each parameter with sys.k, sys.r, etc.)\n\nThe additional problems with this pattern are:\n\nthere are no ways to enforce parameter settings rules with useful error messages, for example ensuring postive numbers \nparameter maps are not easy to work with since they are flat\nparameter maps are not printed with heirarcy and are therefore not easily saved/retrieved to/from file using TOML or JSON","category":"section"},{"location":"#A-Better-Way","page":"Home","title":"A Better Way","text":"ModelingToolkitParameters.jl exports an abstract type Params that can be used to build parameter maps using Julia structs.  The Motor component can now be defined as follows where a mutable Julia struct MotorParams is defined with the same names as the Motor component parameters.\n\nusing ModelingToolkitParameters\n@kwdef mutable struct MotorParams <: Params\n    k::Float64 = 0.1\n    r::Float64 = 0.01\n    l::Float64 = 1e-3\nend\n\n@component function Motor(; name)\n  pars = @parameters begin\n    k \n    r\n    l\n  end\n  vars = @variables begin\n    v(t)\n    dphi(t) = 0\n    i(t) = 0\n    di(t)\n  end\n  eqs = Equation[\n    D(i) ~ di\n    v ~ i * r + l * di + dphi * k\n    D(dphi) ~ k * i\n    v ~ sin(t)\n  ]\n\n  return ODESystem(eqs, t, vars, pars; name)\nend\n\nNow we can build the parameter map by asking for the pair (=>):  sys::ModelingToolkit.System => p::MotorParams, for example\n\n@mtkbuild sys = Motor()\nmotor_pars = MotorParams(k=1,r=2,l=3)\n\npmap = sys => motor_pars\n\nGives...\n\n3-element Vector{Pair}:\n k => 1.0\n r => 2.0\n l => 3.0\n\nNow we can easily modify parameters using the Julia parameter struct motor_pars.  Like\n\nprob = ODEProblem(sys, pmap, (0.1))\n\nmotor_pars2 = copy(motor_pars)\nmotor_pars2.k = 4.0\n\nprob2 = remake(prob; p = sys => motor_pars2)\n\nNow that our parameters are generated from a Julia struct we have many additional benefits, we can:\n\nuse getproperty to set rules\ndefine print rules (and save/load from file easily)\ndefine copy \ndefine constructors","category":"section"},{"location":"#Model-Heirarchy-and-Catalogs","page":"Home","title":"Model Heirarchy and Catalogs","text":"As we move into heirarcal models, we can continue the patern of defining a struct that maps to the component, however we now add the parameters and the child systems.  We will build a MassSpringDamper component that has the child systems Mass, Spring, and Damper. The Active Suspension model seen here https://github.com/bradcarman/ActiveSuspensionModel/tree/main/ActiveSuspensionModel.jl defines the simple mass, spring, damper components like\n\nBase.@kwdef mutable struct MassParams <: Params\n    m::Real\nend\n\n@component function Mass(; name)\n    pars = @parameters begin\n        m\n    end\n    vars = @variables begin\n        s(t)\n        v(t)\n        f(t)\n        a(t)\n    end\n    systems = @named begin\n        globals = Globals()\n        flange = MechanicalPort()\n    end \n\n    @unpack g = globals\n    \n    eqs = [\n        s ~ flange.x\n        f ~ flange.f\n\n        D(s) ~ v\n        D(v) ~ a\n        m*a ~ f + m*g\n    ]\n    return System(eqs, t, vars, pars; name, systems)\nend\n\n# ------------------------------------------------\n\nBase.@kwdef mutable struct SpringParams <: Params\n    k::Real\nend\n\n@component function Spring(; name)\n    pars = @parameters begin\n        k\n        initial_stretch=missing, [guess=0]\n    end\n    vars = @variables begin\n        delta_s(t)\n        f(t)\n    end\n    systems = @named begin\n        flange_a = MechanicalPort()\n        flange_b = MechanicalPort()\n    end \n    eqs = [\n        delta_s ~ (flange_a.x - flange_b.x) + initial_stretch\n        f ~ k * delta_s\n        flange_a.f ~ +f\n        flange_b.f ~ -f\n    ]\n    return System(eqs, t, vars, pars; name, systems)\nend\n\n# ------------------------------------------------\n\nBase.@kwdef mutable struct DamperParams <: Params\n    d::Real\nend\n\n@component function Damper(; name)\n    pars = @parameters begin\n        d\n    end\n    vars = @variables begin\n        delta_s(t), [guess=0]\n        f(t), [guess=0]\n    end\n    systems = @named begin\n        flange_a = MechanicalPort()\n        flange_b = MechanicalPort()\n    end \n    eqs = [\n        delta_s ~ flange_a.x - flange_b.x\n        f ~ D(delta_s) * d\n        flange_a.f ~ +f\n        flange_b.f ~ -f\n    ]\n    return System(eqs, t, vars, pars; name, systems)\nend\n\nNow, we can build a composite component MassSpringDamper\n\n@component function MassSpringDamper(;name)\n\n    systems = @named begin\n        damper = Damper()\n        body = Mass()\n        spring = Spring()\n        port_m = MechanicalPort()\n        port_sd = MechanicalPort()        \n    end\n\n    eqs = [       \n        connect(damper.flange_a, spring.flange_a, body.flange, port_m)\n        connect(port_sd, spring.flange_b, damper.flange_b)\n    ]\n\n    return System(eqs, t, [], []; systems, name)\nend\n\nThis component's parameter struct is then comprised of matching names of the child systems\n\nBase.@kwdef mutable struct MassSpringDamperParams <: Params\n    # systems\n    damper::DamperParams = DamperParams()\n    body::MassParams = MassParams()\n    spring::SpringParams = SpringParams()\nend\n\nThis model will require several MassSpringDampers representing the wheels, the car and suspension, and the seat and passanger.  We can build a Catalog of these components easily like\n\nconst seat = MassSpringDamperParams(;body=MassParams(m=100), spring=SpringParams(k=1000), damper=DamperParams(d=1))\nconst car = MassSpringDamperParams(;body=MassParams(m=1000), spring=SpringParams(k=1e4), damper=DamperParams(d=10))\nconst wheel = MassSpringDamperParams(;body=MassParams(m=25), spring=SpringParams(k=1e2), damper=DamperParams(d=1e4))\n\nNow when we build the top level model\n\n@component function Model(; name)\n\n    systems = @named begin\n        seat = MassSpringDamper()\n        car_and_suspension = MassSpringDamper()\n        wheel = MassSpringDamper()\n        road_data = Road()\n        road = Position()\n        force = Force()\n        pid = Controller()\n        err = Add() \n        set_point = Constant()\n        seat_pos = PositionSensor()\n        flip = Gain()\n    end\n\n    eqs = [\n        \n        # mechanical model\n        connect(road.s, road_data.output)\n        connect(road.flange, wheel.port_sd)\n        connect(wheel.port_m, car_and_suspension.port_sd)\n        connect(car_and_suspension.port_m, seat.port_sd, force.flange_a)\n        connect(seat.port_m, force.flange_b, seat_pos.flange)\n        \n        # controller        \n        connect(err.input1, seat_pos.output)\n        connect(err.input2, set_point.output)\n        connect(pid.err_input, err.output)\n        connect(pid.ctr_output, flip.input)\n        connect(flip.output, force.f)        \n    ]\n\n    return System(eqs, t, [], []; systems, name)\nend\n\nThe parameter struct can be easily created from this catalog\n\nBase.@kwdef mutable struct ModelParams <: Params\n    # parameters\n    g::Real = g\n    # systems\n    seat::MassSpringDamperParams = seat\n    car_and_suspension::MassSpringDamperParams = car\n    wheel::MassSpringDamperParams = wheel\n    road_data::RoadParams = RoadParams()\n    pid::ControllerParams = ControllerParams()\n    err::AddParams = subtract\n    set_point::ConstantParams = ConstantParams()\n    flip::GainParams = GainParams(k=-1)\nend","category":"section"},{"location":"#Speed","page":"Home","title":"Speed","text":"As mentioned previously, using the keyword default patern for model parameter setting is not a good way to build several model variations, as this requires fully compiling/simplifying the model from scratch each time.  A better way was shown with ModelingToolkitParameters.jl using remake and proving an updated parameter map.  However, this way is still not the fastest.  The most efficient approach is to use SymbolicIndexingInterface.jl.  ModelingToolkitParameters.jl provides a cache function that implements the SymbolicIndexingInterface.jl utility to provide a more efficient use of remake.  The example below demonstrates this comparison.\n\nusing ModelingToolkit\nusing ModelingToolkitParameters\nusing ActiveSuspensionModel\nusing SciMLBase\nusing BenchmarkTools\n\n@mtkcompile model = ActiveSuspensionModel.Model()\nmodel_pars = ActiveSuspensionModel.ModelParams()\nprob = ODEProblem(model, model=>model_pars, (0, 10))\n\n# Slow Option\nmodel_pars.seat.body.m = 200                                    # change parameters\ntime_slow = @belapsed prob2 = remake($prob; p = $model => $model_pars)  # remake ODEProblem\n\n# Fast Option\nmodel_setters = cache(model, ActiveSuspensionModel.ModelParams);# build cache (one time only)\n\nmodel_pars.seat.body.m = 300                                    # change parameters\ntime_fast = @belapsed prob3 = remake($prob, $model_setters, $model => $model_pars)  # remake ODEProblem\n\n@show time_slow time_fast # hide\nnothing #hide","category":"section"}]
}
